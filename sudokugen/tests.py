import asyncio

import numpy as np
import pytest

from . import db
from .constants import BOARD_DIM, COMPLETE_ROW, BLOCK_ARRAY
from . import gen_sol
from . import transform as tf



@pytest.fixture
def board():
    return np.array(
        [[1, 3, 5, 2, 7, 8, 9, 6, 4],
         [6, 8, 2, 4, 9, 5, 7, 1, 3],
         [9, 7, 4, 3, 1, 6, 5, 2, 8],
         [2, 6, 1, 9, 4, 7, 8, 3, 5],
         [3, 5, 7, 6, 8, 2, 4, 9, 1],
         [8, 4, 9, 1, 5, 3, 6, 7, 2],
         [7, 2, 3, 5, 6, 4, 1, 8, 9],
         [5, 9, 6, 8, 3, 1, 2, 4, 7],
         [4, 1, 8, 7, 2, 9, 3, 5, 6]])


def assert_board_is_valid(board):
    """
    Solutions and puzzles generated by
    backtracking are valid automatically
    from algorithm implementation for generating
    possible candidates for each cell. However,
    transformations should be checked explicitly.

    (It's also good to use this function to
     check that backtracking is implemented
     correctly in solution/puzzle generation)
    """
    for n in range(BOARD_DIM):
        assert set(board[:, n]) == COMPLETE_ROW
        assert set(board[n, :]) == COMPLETE_ROW
        assert set(board[BLOCK_ARRAY == n]) == COMPLETE_ROW


def test_group_blocks():
    assert np.all(np.equal(gen_sol.group_blocks(), BLOCK_ARRAY))


def test_squares_group():
    groups, lookup = gen_sol.squares()
    assert lookup[(1, 1)] == 0
    assert lookup[(1, 8)] == 6
    assert lookup[(8, 1)] == 2
    assert (4, 8) in groups[7]


def test_squares_choices():
    board = np.array(
      [[0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0],
       [0, 2, 0, 0, 0, 0, 0, 0, 0],
       [0, 4, 0, 0, 0, 0, 0, 0, 0],
       [0, 9, 0, 0, 0, 0, 0, 0, 0],
       [0, 7, 0, 0, 0, 0, 0, 3, 0],
       [0, 5, 0, 0, 0, 0, 0, 0, 0],
       [0, 6, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0]])

    choices = gen_sol.choices_from_square
    assert choices(board, 8, 1) == {1, 2, 3, 4, 7, 8, 9}
    assert choices(board, 0, 7) == {1, 2, 3, 4, 5, 6, 7, 8, 9}
    assert gen_sol.construct_candidates(board, 8, 1) == {3, 8}


def test_get_unfilled_cell():
    board = np.full((BOARD_DIM, BOARD_DIM), 1)
    board[2, 2] = 0
    assert gen_sol.get_unfilled_cell_rand(board) == (2, 2)


def test_get_unfilled_cell_all_filled():
    board = np.full((BOARD_DIM, BOARD_DIM), 1)
    with pytest.raises(IndexError):
        gen_sol.get_unfilled_cell_rand(board)


def test_backtrack_iter():
    board = np.zeros((BOARD_DIM, BOARD_DIM,), dtype=int)
    sol = gen_sol.backtrack_iter(board)
    assert len(np.argwhere(sol == 0)) == 0
    assert_board_is_valid(sol)


def test_x_translate(board):
    assert np.all(np.equal(tf.x_translate(board, times=3), board))
    for n in range(3):
        assert_board_is_valid(tf.x_translate(board, times=n+1))


def test_y_translate(board):
    assert np.all(np.equal(tf.y_translate(board, times=3), board))
    for n in range(3):
        assert_board_is_valid(tf.y_translate(board, times=n+1))


def test_rotate(board):
    for n in range(3):
        assert_board_is_valid(tf.rotate(board, times=n+1))


def test_mirror_x(board):
    assert_board_is_valid(tf.mirror_x(board))


def test_mirror_y(board):
    assert_board_is_valid(tf.mirror_y(board))


def test_shuff_numbers(board):
    assert_board_is_valid(tf.shuffle_numbers(board))

